#!/bin/sh

# Copyright (c) 2007-2008 Aleksey Cheusov <vle@gmx.net>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

set -e

. pipestatus

############################################################
# user settable variables
if test -z "$PKGSRCDIR"; then
    PKGSRCDIR=/usr/pkgsrc
fi

if test -z "$BMAKE"; then
    BMAKE=make
fi

############################################################
usage (){
    cat 1>&2 <<EOF
pkg_src_summary - builds summary information
about source packages

usage:
  pkg_src_summary [OPTIONS] [pkgpath1 pkgpath2 ...]
  pkg_src_summary -s [OPTIONS]
OPTIONS:
  -h|--help              display this help message
  -p|--make-plist        generate PLIST using 'bmake plist'
  -f|--fields <fields>
  -f|--fields=<fields> list of fields (separated by space or comma)
                         to be included to summary,
                         by default FULL summary is generated
  -s|--slave-mode        ready for use as paexec slave/remote program
  -a|--add-fields <fields>  add the specified fields to the list
                               of default ones
  -r|--rem-fields <fields>  remove the specified fields from the list
                               of default ones
  -d|--with-deps      also generates summary for dependancies (DEPENDS)
  -D|--with-bdeps     also generates summary for dependancies (BUILD_DEPENDS)
  -A|--with-alldeps   implies -d and -D
  -m|--multi          generate ASSIGNMENTS field
                      for multi-variant packages
  -M|--MULTI          implies -m and move/add ASSIGNMENTS to PKGPATH field
EOF
}

# list of fields for default pkg_src_summary
if test -z "$PSS_FIELDS"; then
    PSS_FIELDS='PKGNAME PKGPATH DEPENDS BUILD_DEPENDS CONFLICTS HOMEPAGE COMMENT LICENSE ONLYFOR NOTFOR MAINTAINER CATEGORIES NO_BIN_ON_FTP NO_SRC_ON_FTP NO_BIN_ON_CDROM NO_SRC_ON_CDROM LICENSE ALLSRCFILES DESCRIPTION PLIST' # CVS_CHECKSUM'
fi

if test -z "$PSS_PPERS"; then
    PSS_PPERS=10
fi

add_fields (){
    for f in "$@"; do
	PSS_FIELDS="$PSS_FIELDS $f"
    done
}

rem_fields (){
    for f in "$@"; do
	PSS_FIELDS="$(echo $PSS_FIELDS | sed s,$f,,g)"
    done
}

process_options (){
    while test $# -ne 0; do
	case "$1" in
	    -h|--help)
		usage
		exit 0;;
	    -f|--fields)
		PSS_FIELDS="$(echo $2 | tr , ' ')"
		shift;;
	    -f=*|--fields=*)
		PSS_FIELDS="$(echo $1 | cut -f2 -d= | tr , ' ')";;
	    -a|--add-fields)
		add_fields $(echo $2 | tr , ' ')
		shift;;
	    -a=*|--add-fields=*)
	        add_fields $(echo $1 | cut -f2 -d= | tr , ' ');;
	    -r|--rem-fields)
		rem_fields $(echo $2 | tr , ' ')
		shift;;
	    -r=*|--rem-fields=*)
	        rem_fields $(echo $1 | cut -f2 -d= | tr , ' ');;
	    -s|--slave-mode)
		slave=1;;
	    -p|--make-plist)
		make_plist='-p';;
	    -d|--with-deps)
		with_dep=1;;
	    -D|--with-bdeps)
		with_bdep=1;;
	    -A|--with-alldeps)
		with_dep=1
		with_bdep=1;;
	    -m)
	        multi_var=1;;
	    -M)
	        multi_var=2;;
	    --)
		shift
		break;;
	    -*)
		echo "Unrecognized option " $1 ". Type --help to see usage" 1>&2
		exit 1;;
	    *)
		break;;
	esac
	shift
    done

    pkgpaths="$@"
}

process_options $PSS_OPTIONS "$@"

if test "$multi_var"; then
    # VARIANTS7 - artificial field keeping all variable assignments
    # for multi-variant packages. This should be in pkgsrc but
    # idea was declined by pkgsrc developers.
    # http://mail-index.netbsd.org/tech-pkg/2008/07/20/msg001320.html
    add_fields 'VARIANTS7'
fi

if echo "$PSS_FIELDS" | grep DESCRIPTION > /dev/null; then
    field_descr=1
fi
if echo "$PSS_FIELDS" | grep PLIST > /dev/null; then
    field_plist=1
fi
if echo "$PSS_FIELDS" | grep CVS_CHECKSUM > /dev/null; then
    field_cvs_checksum=1
fi
varnames="`echo $PSS_FIELDS |
   awk '{gsub(/PLIST/, \"\")
         gsub(/CVS_CHECKSUM/, \"\")
         gsub(/ONLYFOR/, \"ONLY_FOR_PLATFORM\")
         gsub(/NOTFOR/,  \"NOT_FOR_PLATFORM\")
         gsub(/DESCRIPTION/, \"DESCR_SRC\")
         print}'`"

############################################################
cd $PKGSRCDIR

tmp_dir="/tmp/pkg_src_summary.$$"
trap "rm -rf $tmp_dir" 0 1 2 15
mkdir -m 700 "$tmp_dir"

tmpfn=$tmp_dir/pkgdirs2info.txt
errsfn=$tmp_dir/errors.txt
summaryfn=$tmp_dir/summary.txt
tempsummaryfn=$tmp_dir/temp_summary.txt
real_plistfn=$tmp_dir/real_plist.txt
multi_pkgs_fn=$tmp_dir/multi_pkgs.txt
normal_pkgs_fn=$tmp_dir/normal_pkgs.txt

############################################################
enrich_summary (){
    awk -F= '
    $1 == "DESCR_SRC" {
	fn = $2
	while (0 < ret = (getline < fn)){
	    print "DESCRIPTION=" $0
	}
	if (ret < 0){
	    printf "reading from `" fn "` failed\n" > "/dev/stderr"
	    exit 1
	}
	next
    }
    {
	gsub(/ONLY_FOR_PLATFORM/, "ONLYFOR")
	gsub(/NOT_FOR_PLATFORM/, "NOTFOR")
	print
    }' "$@"
}

enrich_Makefile (){
    cat <<EOF
#####################################################################
.PHONY: my-show-vars
my-show-vars:
.for VARNAME in \${VARNAMES}
.if !empty(\${VARNAME})
	@\${ECHO} \${VARNAME}=\${\${VARNAME}:Q}
.endif
.endfor

#####################################################################
.if defined(DIST_SUBDIR) && !empty(DIST_SUBDIR)
_ALLSRCFILES=    \${DISTFILES:@f@\${DIST_SUBDIR}/\${f}@} \
                 \${PATCHFILES:@f@\${DIST_SUBDIR}/\${f}@}
.else
_ALLSRCFILES=     \${_DISTFILES} \${_PATCHFILES}
.endif
ALLSRCFILES=     \${_ALLSRCFILES:O:u}

#####################################################################
# for multi-variant packages and bulk build software
.for i in \${_PBULK_MULTI}
.if !empty(\${_PBULK_MULTI_LIST.\${i}})
VARIANTS7+=	\${_PBULK_MULTI_VAR.\${i}}=\${\${_PBULK_MULTI_LIST.\${i}}:ts,}
.endif
.endfor

EOF
}

prepand_PLIST () {
    awk '/^[^@]/ {print "PLIST=" $0}' "$@"
}

pkgpath2multivar_opts (){
    sed -e 's|^[^:]*:||' -e 's|,| |g' -e "s|[^ ][^ ]*|'&'|g" -e 's|~| |g'
}

cd_and_print_summary (){
    # $1 - pkgpath
    real_pkgpath="`echo $1 | cut -d: -f1`"
    if test "$real_pkgpath" = "$1"; then
	var_assigns=''
    else
	var_assigns="`echo $1 | pkgpath2multivar_opts`"
    fi

    extra_mk=''
    if test -f mk/pbulk/pbulk-index.mk; then
	extra_mk='-f ../../mk/pbulk/pbulk-index.mk'
    fi
    ( cd "$real_pkgpath" && enrich_Makefile |
	eval ${BMAKE} -f ./Makefile $extra_mk -f - my-show-vars \
	    VARNAMES="'$varnames'" $var_assigns ) > "$tmpfn" || return 1

    enrich_summary "$tmpfn" >"$summaryfn" || return 1

    # VAR_ASSIGNMENTS
    if test "$var_assigns"; then
	printf 'ASSIGNMENTS=' >>"$summaryfn" || return 1
	printf "%s\n" "$var_assigns" | \
	    sed -e 's| |~|g' -e "s|'~'| |g" -e "s|'||g" >>"$summaryfn" \
	    || return 1
    fi

    # CVS_CHECKSUM
    if test "$field_cvs_checksum"; then
	cvs_checksum "$real_pkgpath" > "$tmpfn" || return 1
	read cksum < "$tmpfn" || return 1
	printf "CVS_CHECKSUM=%s\n" "$cksum" >>"$summaryfn" || return 1
    fi

    # not expanding PLIST yet
    if test "$field_plist"; then
	plist_fn="$real_pkgpath/PLIST"
	if test -n "$make_plist"; then
	    rm -f "$real_plistfn" || return 1
	    ( cd "$real_pkgpath" && eval ${BMAKE} PLIST="$real_plistfn" \
		$var_assigns plist ) 1>&2 || return 1
	     prepand_PLIST "$real_plistfn" >> "$summaryfn" || return 1
	elif test -f $plist_fn; then
	    prepand_PLIST $plist_fn >>"$summaryfn" || return 1
	fi
    fi
}

generate_summary (){
    # general information
    if cd_and_print_summary $1 2>"$errsfn"
    then
	cat "$summaryfn"

	echo '' # empty line - separator 
    else
	printf ' ------------------\n' 1>&2
	printf "Bad package %s, skipped\n" "$1" 1>&2
	cat "$errsfn" 1>&2
    fi
}

############################################################
packages2stdout__1per_line (){
    if test $# -eq 0; then
	# processing stdin
	cat 
    else
	# processing arguments
	for pkgpath in "$@"; do
	    echo "$pkgpath"
	done
    fi
}

packages2stdout (){
    packages2stdout__1per_line "$@" |
    awk -v pss_ppers=$PSS_PPERS '
    {
        printf " %s", $0
    }
    (NR % pss_ppers) == 0 {
        printf "\n"
    }
    END {
        if ((NR % pss_ppers) != 0){
            printf "\n"
        }
    }'
}

process_one_by_one (){
    if test "$slave"; then
	prepand="awk '"'{print " " $0}'"'"
    else
	prepand=cat
    fi

    while read pkgpaths; do
	for pkgpath in $pkgpaths; do
	    generate_summary "$pkgpath" | eval $prepand
	done

	if test "$slave"; then
	    echo '' # for paexec
	fi
    done
}

add_NR (){
    awk '{print NR, $0}'
}

rem_two_first_tokens (){
    awk '{$1 = $2 = ""; print substr($0, 3)}'
}

restore_order (){
    runpipe0 add_NR '|' sort -k2n -k1n '|' rem_two_first_tokens
}

############################################################
# direct packages
partial_summary_fn=$tmp_dir/partial_summary.txt

if test "$PSS_SLAVES"; then
    qfields="$(echo $PSS_FIELDS | sed 's| |,|g')"
    environ="PSS_SLAVES= BMAKE=$BMAKE CKSUM=$CKSUM PKGSRCDIR=$PKGSRCDIR"

    runpipe0 \
	packages2stdout $pkgpaths '|' \
	paexec -l -n "$PSS_SLAVES" -t "$PSS_TRANSPORT" \
	   -c "env $environ $0 -s -f '$qfields'" > "$tempsummaryfn"

    restore_order < "$tempsummaryfn" > "$partial_summary_fn"
elif test "$slave"; then
    process_one_by_one
    exit 0
else
    PSS_PPERS=1 # one package per line for local running

    runpipe0 \
	packages2stdout $pkgpaths '|' \
	process_one_by_one > "$partial_summary_fn"
fi

############################################################
# multi-variant packages
export PSS_FIELDS

summary2all_variants (){
    awk '
$1 ~ /PKGPATH=/ {
   pkgpath = substr($0, 9)
   next
}

$1 ~ /VARIANTS7=/ {
   variants = substr($0, 11)
   next
}

NF == 0 {
   $0 = variants
   count = 0
   for (k=1; k <= NF; ++k){
      values = varname = $k
      sub(/=.*$/, "", varname)
      sub(/^[^=]*=/, "", values)

      cnt = split(values, vals, /,/)

      if (count){
         new_count = count
         for (i=1; i <= count; ++i){
            if (!(i in variant)) continue

            for (j=1; j <= cnt; ++j){
               ++new_count
               variant [new_count] = (variant [i] "," varname "=" vals [j])
            }
            delete variant [i]
         }
         count = new_count
      }else{
         for (j=1; j <= cnt; ++j){
            variant [j] = (varname "=" vals [j])
         }
         count = cnt
      }
   }

   for (i = 1; i <= count; ++i){
      if (i in variant)
         print pkgpath ":" variant [i]
   }
   pkgpath = variants = ""

   delete variant
}
' "$@"
}

if test "_$multi_var" = _2; then
    move_ASSIGNMENTS_to_PKGPATH (){
	pkg_assignments2pkgpath "$@"
    }
else
    move_ASSIGNMENTS_to_PKGPATH (){
	cat "$@"
    }
fi

if test "$multi_var"; then
    pkg_grep_summary VARIANTS7 'fvalue != ""' \
	< $partial_summary_fn >$multi_pkgs_fn

    if test -s $multi_pkgs_fn; then
	pkg_grep_summary VARIANTS7 'fvalue == ""' \
	    < $partial_summary_fn >$normal_pkgs_fn
	grep -v VARIANTS7 $normal_pkgs_fn > $partial_summary_fn || true

	rm $normal_pkgs_fn

	runpipe_re '0 0 [01] 0' \
	    summary2all_variants < $multi_pkgs_fn '|' \
	    pkg_src_summary $make_plist '|' \
	    grep -v VARIANTS7 '|' \
	    move_ASSIGNMENTS_to_PKGPATH >> "$partial_summary_fn"
    fi
fi

############################################################
# dependencies

extra_deps_fn=$tmp_dir/extra_deps.txt

processed_pkgs_fn=$tmp_dir/processed_pkgs.txt
awk -F= '$1 == "PKGPATH" {print $2}' \
    < "$partial_summary_fn" > "$processed_pkgs_fn"

while test -n "${with_dep}${with_bdep}"; do
    awk -v with_dep=$with_dep -v with_bdep=$with_bdep \
	-v processed_pkgs_fn=$processed_pkgs_fn '
    BEGIN {
	while (0 < (ret = (getline < processed_pkgs_fn))){
	    processed_pkgs [$0] = 1
	}
	if (ret){
	    print "reading error" > "/dev/stderr"
	    exit (1)
	}
    }
    /^PKGPATH=/ {
	pkgpaths [substr($0, 9)] = 1
	next
    }
    /^DEPENDS=/ && with_dep {
	$0 = substr($0, 9)
	gsub(/[^ ]*:[.][.]\/[.][.]\//, "")
	for (i=1; i <= NF; ++i){
	    sub(/\/+$/, "", $i)
	    depends [$i] = 1
	}
	next
    }
    /^BUILD_DEPENDS=/ && with_bdep {
	$0 = substr($0, 15)
	gsub(/[^ ]*:[.][.]\/[.][.]\//, "")
	for (i=1; i <= NF; ++i) depends [$i] = 1
	next
    }
    END {
	for (d in depends){
	    if (! (d in pkgpaths) && ! (d in processed_pkgs)){
		print d
	    }
	}
    }
    ' "$partial_summary_fn" > "$extra_deps_fn"

    if test -s "$extra_deps_fn"; then
#	echo "inside! pkg_src_summary $make_plist < \"$extra_deps_fn\" >> \"$partial_summary_fn\"" 1>&2
	pkg_src_summary $make_plist \
	    < "$extra_deps_fn" >> "$partial_summary_fn"
	cat "$extra_deps_fn" >> "$processed_pkgs_fn"
    else
	break
    fi
done

cat "$partial_summary_fn"
