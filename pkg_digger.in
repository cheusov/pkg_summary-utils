#!/bin/sh

# Copyright (c) 2010 Aleksey Cheusov <vle@gmx.net>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

set -e

. pipestatus

export LC_ALL=C

usage () {
    cat 1>&2 <<EOF
pkg_digger is a pkg summary searcher
(backend for pkg_search and pkg_online_find).
usage: pkg_digger -h
       pkg_digger -f
       pkg_digger -s
       pkg_digger [-n] fsq1 [fsq2 ...]
       pkg_digger -1|-3|-9|-i [-r] [-q] pkgpair1 [pkgpair2...]
where pkgpair is <PKGPATH>,<PKGNAME>
and fsq is <field>:<strategy>:<query>
OPTIONS:
   -h         display this screen
   -s         display available search strategies
   -f         display available fields for search in
   -1         display 1-line information about packages (by PKGPAIR)
   -3         display short information about packages (by PKGPAIR)
   -9|-i      display full information about packages (by PKGPAIR)
   -r         raw output in pkg_summary(5) format
   -q         quiet mode, do not print "No matches found" to stderr
   -n <limit>    maximum number of results
EOF
}

if test -z "$PKG_DIGGER_SUMMARY"; then
    echo 'PKG_DIGGER_SUMMARY environment variable must be set' 1>&2
    exit 1
fi

if test $# -eq 0; then
    usage
    exit 2
fi

limit=1000000000

show_strats (){
    awk -F= 'NF > 0 {hash [$1]=0} END {for (i in hash) print i}' \
	"$PKG_DIGGER_SUMMARY"
    exit 0
}

FIELDS_3='PKGNAME PKGPATH HOMEPAGE COMMENT MAINTAINER CATEGORIES DESCRIPTION'
FIELDS_9=''

while getopts hsf139irqn: f; do
    case "$f" in
	s)    pkg_grep_summary -T | tr ' ' '
'; exit 0;;
	f)    show_strats;;
	9|i)  info=1;;
	3)    shortinfo=1; FIELDS=-f`echo $FIELDS_3 | tr ' ' ,`;;
	1)    onelineinfo=1;;
	r)    raw_format=1;;
	q)    quiet_mode=1;;
	n)    limit=$OPTARG;;
	h)    usage; exit 0;;
	?)    printf "Run pkg_digger -h for details\n"; exit 2;;
    esac
done

shift `expr $OPTIND - 1`

gen_summary4view (){
    if test -n "$raw_format"; then
	cat
    else
	pkg_summary4view
    fi
}

summary2onelineinfo (){
    awk -v quiet_mode="$quiet_mode" \
	'/^PKGNAME=/ {pkgbase = substr($0, 9); sub(/-[^-]*$/, "", pkgbase); next}
	/^PKGPATH=/ {pkgpath = substr($0, 9); next}
	/^COMMENT=/ {comment = substr($0, 9); next}
	NF == 0 {
	    pos = index(pkgpath, "/")
	    if (substr(pkgpath, pos+1) == pkgbase)
		printf "%-25s - %s\n", pkgpath, comment
	    else
		printf "%-25s - %s\n", pkgpath "(" pkgbase ")", comment
	    found = 1
	}
	END {
	    if (!found){
		if (!quiet_mode)
		    print "No matches found" > "/dev/stderr"
		exit 20
	    }
	}' "$@"
}

if test -n "$onelineinfo"; then
    # -1
    pkg_grep_summary -r -fPKGNAME,PKGPATH,COMMENT -i \
	    -t strlist PKGPAIR "$*" < "$PKG_DIGGER_SUMMARY" |
    summary2onelineinfo

    exit 0
elif test -n "${shortinfo}${info}"; then
    # -3|-9
    runpipe \
	pkg_grep_summary $FIELDS -r -i \
	    -t strlist PKGPAIR "$*" < "$PKG_DIGGER_SUMMARY" '|' \
	gen_summary4view
    if test "$pipestatus_1" != 0; then
	test "$quiet_mode" = 1 || echo 'No matches found' 1>&2
	exit 20
    fi

    exit 0
else
    # f:s:q
    for i in "$@"; do
	field=`echo "$i" | cut -d: -f1`
	strat=`echo "$i" | cut -d: -f2`
	query=`echo "$i" | cut -d: -f3`
	pkg_grep_summary -fPKGNAME,PKGPATH,ASSIGNMENTS -i \
	    -t "$strat" "$field" "$query" < "$PKG_DIGGER_SUMMARY"
    done |
    runawk -v quiet_mode="$quiet_mode" -v limit="$limit" \
	-e '
    /^PKGPATH=/ {
	pkgpath = substr($0, 9)
	sub(/:.*/, "", pkgpath)
	next
    }
    /^PKGNAME=/ {
	pkgbase = substr($0, 9)
	sub(/-[^-]*$/, "", pkgbase)
	next
    }
    NF == 0 {
	print pkgpath "," pkgbase
	found = 1
    }
    END {
	if (!found){
	    if (!quiet_mode)
		print "No matches found"
	    exit 20
	}
    }'
    exit 0
fi
