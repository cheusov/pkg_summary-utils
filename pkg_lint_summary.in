#!/usr/bin/env runawk

# Copyright (c) 2010, Aleksey Cheusov <vle@gmx.net>
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
#       notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
#       copyright notice, this list of conditions and the following
#       disclaimer in the documentation and/or other materials provided
#       with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


############################################################

#env "LC_ALL=C"

#use "pkgsrc-dewey.awk"
#use "power_getopt.awk"
#use "psu_funcs.awk"
#use "has_prefix.awk"
#use "braceexpand.awk"
#use "glob.awk"

############################################################
#.begin-str help
# pkg_lint_summary - does sanity check for summaries
# usage: pkg_lint_summary -h
#        pkg_lint_summary [OPTIONS] [files...]
# OPTIONS:
#   -h|--help   display this help
#   -l          checks REQUIRES/PROVIDES consistency
#   -L          checks that libs from REQUIRES are present on filesystem
#   -d          checks that all packages listed in DEPENDS are in the summary
#.end-str
############################################################

BEGIN {
	prefix = ENVIRON ["PREFIX"]
	if (prefix == "")
		prefix = "@prefix@"

	opt_L = getarg("L")
	opt_l = getarg("l")
	opt_d = getarg("d")
	cnt = 0

	if (!opt_L && !opt_l && !opt_d){
		print "One of the following options should be applied: -L, -l or -d" \
			> "/dev/stderr"
		exitnow(1)
	}
}

/^PKGNAME=/{
	pkgname = substr($0, 9)
	pkgbase = pkgname2pkgbase(pkgname)
	pkgver  = pkgname2version(pkgname)
}

/^PKGPATH=/{
	pkgpath = substr($0, 9)
}

NF == 0 {
	for (i=1; i < 10000 && ((pkgbase SUBSEP i) in pkg2ver); ++i){
		pkg2ver [pkgbase, i] = pkgver
	}
	pkg2ver [pkgbase] = 1
}

opt_l || opt_L {
	if (/^REQUIRES=/){
		requires1 = substr($0, 10)
		if (!(requires1 in provides2pkg))
			requires [++requires_cnt] = requires1
		if (opt_L) { # && !has_prefix(requires1, prefix)){
			dirname = requires1
			sub(/\/[^\/]*\/?$/, "", dirname)
			syslibdirs [dirname] = 1
		}
	}else if (opt_l && /^PROVIDES=/){
		provides1 = substr($0, 10)
		provides2pkg [provides1] = 1
	}else if (NF == 0){
		pkg = (pkgpath " " pkgname)
		for (i=1; i <= requires_cnt; ++i){
#			print "r:", requires [i], pkg
			req = requires [i]
			reqd_libs [req] = 1
			reqd_libs2where [req, ++reqd_libs2cnt [req]] = pkg
		}

		requires_cnt = 0
	}
}

opt_d {
	if (/^PKGNAME=/){
		pkgnames [substr($0,9)] = 0
	}else if (/^DEPENDS=/){
		cnt=split(substr($0, 9), arr)
		for (i=1; i <= cnt; ++i){
			deps [++deps_cnt] = arr [i]
		}
	}else if (NF == 0){
		for (i=1; i <= deps_cnt; ++i){
			if (! (i in deps))
				break
#			print pkgpath, pkgbase, i, "->", deps [i]
			depends [pkgpath, pkgbase, i] = deps [i]
		}
		deps_cnt = 0
	}
}

NF == 0 {
	pkgname = pkgpath = pkgver = ""
}

function check_ver (ver, condition){
}

function print_lib_notfound (prefix, lib,                        i){
	for (i=1; i <= reqd_libs2cnt [lib]; ++i){
		print prefix ": not_found " lib, reqd_libs2where [lib, i]
	}
}

END {
	ex = 0

	# -L
	if (opt_L){
		for (libdir in syslibdirs){
			pipe = "ls -1 '" libdir "' 2>/dev/null"
			while((pipe | getline lib) > 0){
				syslibs [libdir "/" lib] = 0
			}
			close(pipe)
		}

		for (p in reqd_libs){
			if (!(p in syslibs)){
				print_lib_notfound("L", p)
				ex = 1
			}
		}
	}

	# -l
	if (opt_l){
		for (p in reqd_libs){
			if (has_prefix(p, prefix) && !(p in provides2pkg)){
				print_lib_notfound("l", p)
				ex = 1
			}
		}
	}

	# -d
	if (opt_d){
		for (d in depends){
			# d: pkgpath SUBSEP pkgname SUBSEP <index>
			dep    = depends [d]

			split(d, arr, SUBSEP)

			if (dep !~ /[{]/){
				pkgdep = pkgname2pkgbase(dep)
				ex_d = 1
				if (pkgdep ~ /[*?\[\]]/){
					ere = glob2ere(dep)
					for (i in pkgnames){
						if (i ~ ere){
							ex_d = 0
							break
						}
					}
				}else{
					ex_d = !(pkgdep in pkg2ver)
				}
				if (ex_d){
					print "d: not_found", dep, "<-", arr [1], arr [2]
					ex = 1
				}
			}else{
				cnt = split(braceexpand(dep), deps)
				ok = 0
				for (i=1; i <= cnt; ++i){
					pkgdep = pkgname2pkgbase(deps [i])
					if (pkgdep in pkg2ver){
						ok = 1
						break
					}
				}
				if (!ok){
					print "d2: not_found", dep, "<-", arr [1], arr [2]
					ex = 1
				}
			}
		}
	}

	exitnow(ex)
}
